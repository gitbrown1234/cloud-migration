import os, sys
import time
import json
import requests

# Add the lib directory to the sys.path for splunklib
# This assumes the script is placed in $SPLUNK_HOME/etc/apps/<your_app>/bin/
# and splunklib is in $SPLUNK_HOME/etc/apps/<your_app>/lib/
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "lib"))
from splunklib.searchcommands import dispatch, GeneratingCommand, Configuration, Option, validators
from splunklib.searchcommands import dispatch, GeneratingCommand, Configuration, Option, validators


@Configuration()
class KVStoreMigrator(GeneratingCommand):
    """
    The kvstoremigrator command processes JSON files from a specified base path
    and posts their data to Splunk KVStore collections.

    Example:

    ``| kvstoremigrator splunk_host="https://localhost:8089" auth_token="YOUR_TOKEN" base_path="/opt/splunk/var/lib/splunk/kvstorebackup/"``

    Optional arguments:

    ``| kvstoremigrator ... include_apps="my_app1,my_app2"``
    ``| kvstoremigrator ... all_apps=true``
    ``| kvstoremigrator ... dry_run=true``
    """

    splunk_host = Option(require=True)
    auth_token = Option(require=True)
    base_path = Option(require=True)
    
    # Optional comma-separated list to filter which apps to process
    # This option is ignored if all_apps=true
    include_apps = Option(require=False, default="")
    
    # Option to process all apps found in the base_path
    all_apps = Option(require=False, validate=validators.Boolean(), default=False)
    
    # Optional dry run mode to simulate the process without posting data
    dry_run = Option(require=False, validate=validators.Boolean(), default=False)

    def generate(self):
        """
        Main generator method for the Splunk custom command.
        It orchestrates the KVStore migration process.
        """
        # Retrieve options provided by the user
        splunk_host = self.splunk_host
        auth_token = self.auth_token
        base_path = self.base_path
        dry_run = self.dry_run
        all_apps = self.all_apps
        
        # Parse include_apps list into a set for efficient lookup, if not processing all apps
        included_apps = set()
        if not all_apps and self.include_apps:
            included_apps = set(a.strip() for a in self.include_apps.split(',') if a.strip())

        self.logger.debug(f"Starting KVStore migration with host: {splunk_host}, base path: {base_path}, dry_run: {dry_run}, all_apps: {all_apps}")
        
        # Validate base path existence
        if not os.path.exists(base_path) or not os.path.isdir(base_path):
            yield self._create_event(
                log_level="ERROR",
                message=f"Invalid path. Please make sure the path exists and is a directory: {base_path}",
                _raw=f"ERROR: Invalid path. Path does not exist or is not a directory: {base_path}"
            )
            return

        # Start processing from the base path
        # Using yield from to propagate events from the nested generator
        yield from self._process_directory(
            base_path, splunk_host, auth_token, included_apps, all_apps, dry_run
        )

    def _create_event(self, log_level, message, **kwargs):
        """
        Helper method to create a consistent event dictionary for yielding.
        All events generated by this command will have these common fields.
        """
        event = {
            '_time': time.time(),
            'log_level': log_level,
            'message': message,
            '_raw': message  # Default raw message for Splunk's _raw field
        }
        event.update(kwargs)  # Add any additional fields passed as kwargs
        return event

    def _post_json_data(self, json_file_path, splunk_host, auth_token, app_name, collection_name, dry_run):
        """
        Reads a JSON file and attempts to post its data to a Splunk KVStore collection.
        Yields events for debugging, success, failure, or network errors.
        """
        endpoint = f'/servicesNS/nobody/{app_name}/storage/collections/data/{collection_name}'
        url = splunk_host + endpoint

        try:
            with open(json_file_path, 'r') as file:
                data_list = json.load(file)  # Load JSON data from file
        except json.JSONDecodeError as e:
            yield self._create_event(
                log_level="ERROR",
                message=f"Failed to parse JSON file {json_file_path}: {e}",
                app_name=app_name,
                collection_name=collection_name,
                json_file=os.path.basename(json_file_path),
                _raw=f"ERROR: Failed to parse JSON file '{json_file_path}'. Error: {e}"
            )
            return
        except Exception as e:
            yield self._create_event(
                log_level="ERROR",
                message=f"Failed to read file {json_file_path}: {e}",
                app_name=app_name,
                collection_name=collection_name,
                json_file=os.path.basename(json_file_path),
                _raw=f"ERROR: Failed to read file '{json_file_path}'. Error: {e}"
            )
            return

        if not data_list:
            yield self._create_event(
                log_level="INFO",
                message=f"JSON file {json_file_path} is empty or contains no data to post.",
                app_name=app_name,
                collection_name=collection_name,
                json_file=os.path.basename(json_file_path),
                _raw=f"INFO: JSON file '{json_file_path}' is empty or contains no data."
            )
            return

        for entry in data_list:
            payload = json.dumps(entry)  # Convert dictionary entry to JSON string
            
            yield self._create_event(
                log_level="DEBUG",
                message=f"Attempting to send payload to {url}",
                payload_size=len(payload),
                app_name=app_name,
                collection_name=collection_name,
                json_file=os.path.basename(json_file_path),
                _raw=f"DEBUG: Attempting to send payload to {url}: {payload[:200]}..." # Truncate payload for _raw
            )

            if dry_run:
                yield self._create_event(
                    log_level="INFO",
                    message=f"DRY RUN: Would have posted payload for {json_file_path}",
                    payload=payload,
                    app_name=app_name,
                    collection_name=collection_name,
                    json_file=os.path.basename(json_file_path),
                    _raw=f"INFO: DRY RUN - Would have posted payload for '{json_file_path}' to KVStore '{collection_name}' in app '{app_name}'. Payload: {payload}"
                )
                continue

            headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Splunk {auth_token}'  # Token-based authorization
            }

            try:
                # Disables SSL verification (equivalent to `-k` in curl).
                # Consider using a proper CA bundle in production for security.
                response = requests.post(
                    url,
                    headers=headers,
                    data=payload,
                    verify=False
                )

                # Handle the HTTP response
                if response.status_code == 201: # 201 Created is typical for successful KVStore POST
                    yield self._create_event(
                        log_level="SUCCESS",
                        message=f"Successfully posted payload for {json_file_path}",
                        status_code=response.status_code,
                        app_name=app_name,
                        collection_name=collection_name,
                        json_file=os.path.basename(json_file_path),
                        payload_sent=payload, # Log the full payload on success
                        _raw=f"SUCCESS: Posted payload for '{json_file_path}' to KVStore '{collection_name}' in app '{app_name}'. Status: {response.status_code}"
                    )
                else:
                    yield self._create_event(
                        log_level="ERROR",
                        message=f"Failed to post payload for {json_file_path}. Status: {response.status_code}, Response: {response.text}",
                        status_code=response.status_code,
                        response_text=response.text,
                        app_name=app_name,
                        collection_name=collection_name,
                        json_file=os.path.basename(json_file_path),
                        payload_attempted=payload, # Log the payload that failed
                        _raw=f"ERROR: Failed to post payload for '{json_file_path}'. Status: {response.status_code}, Response: {response.text}. Payload: {payload}"
                    )
            except requests.exceptions.RequestException as e:
                yield self._create_event(
                    log_level="CRITICAL",
                    message=f"Network error while posting payload for {json_file_path}: {e}",
                    app_name=app_name,
                    collection_name=collection_name,
                    json_file=os.path.basename(json_file_path),
                    payload_attempted=payload,
                    _raw=f"CRITICAL: Network error during KVStore POST for '{json_file_path}'. Error: {e}. Payload: {payload}"
                )

    def _process_directory(self, base_path, splunk_host, auth_token, included_apps, all_apps, dry_run):
        """
        Recursively processes directories (representing Splunk apps) and
        subdirectories (representing KVStore collections) to find and
        process JSON files.
        """
        try:
            # List only directories in the base path (assumed to be app directories)
            directories = [d for d in os.listdir(base_path) if os.path.isdir(os.path.join(base_path, d))]
        except OSError as e:
            yield self._create_event(
                log_level="ERROR",
                message=f"Failed to list directories in base path {base_path}: {e}",
                _raw=f"ERROR: Failed to list directories in base path '{base_path}'. Error: {e}"
            )
            return

        for directory in directories:
            dir_path = os.path.join(base_path, directory)
            app_name = directory

            # Check if the app should be included based on the 'all_apps' or 'include_apps' option
            if not all_apps and included_apps and app_name not in included_apps:
                yield self._create_event(
                    log_level="INFO",
                    message=f"Skipping app '{app_name}' as it's not in the 'include_apps' list and 'all_apps' is false.",
                    app_name=app_name,
                    _raw=f"INFO: Skipping app '{app_name}' (not in 'include_apps' list)."
                )
                continue

            yield self._create_event(
                log_level="INFO",
                message=f"Found app directory: {app_name}",
                app_name=app_name,
                _raw=f"INFO: Found app directory: '{app_name}'."
            )

            try:
                # Process subdirectories inside this app directory (assumed to be KVStore collection directories)
                subdirectories = [d for d in os.listdir(dir_path) if os.path.isdir(os.path.join(dir_path, d))]
            except OSError as e:
                yield self._create_event(
                    log_level="ERROR",
                    message=f"Failed to list subdirectories in app path {dir_path}: {e}",
                    app_name=app_name,
                    _raw=f"ERROR: Failed to list subdirectories in app path '{dir_path}'. Error: {e}"
                )
                continue

            if not subdirectories:
                yield self._create_event(
                    log_level="INFO",
                    message=f"No KV store subdirectories found in app '{app_name}'.",
                    app_name=app_name,
                    _raw=f"INFO: No KV store subdirectories found in app '{app_name}'."
                )

            # Iterate through all subdirectories (collections) as there's no include_collections filter
            for subdirectory in subdirectories:
                sub_dir_path = os.path.join(dir_path, subdirectory)
                collection_name = subdirectory

                yield self._create_event(
                    log_level="INFO",
                    message=f"Found KV store subdirectory: {collection_name}",
                    app_name=app_name,
                    collection_name=collection_name,
                    _raw=f"INFO: Found KV store subdirectory: '{collection_name}' in app '{app_name}'."
                )

                try:
                    # Find all JSON files in this subdirectory (assumed to contain KVStore data)
                    json_files = [f for f in os.listdir(sub_dir_path) if f.endswith('.json')]
                except OSError as e:
                    yield self._create_event(
                        log_level="ERROR",
                        message=f"Failed to list JSON files in collection path {sub_dir_path}: {e}",
                        app_name=app_name,
                        collection_name=collection_name,
                        _raw=f"ERROR: Failed to list JSON files in collection path '{sub_dir_path}'. Error: {e}"
                    )
                    continue

                if not json_files:
                    yield self._create_event(
                        log_level="INFO",
                        message=f"No JSON files found in KV store '{collection_name}' in app '{app_name}'.",
                        app_name=app_name,
                        collection_name=collection_name,
                        _raw=f"INFO: No JSON files found in KV store '{collection_name}' in app '{app_name}'."
                    )

                for json_file in json_files:
                    json_file_path = os.path.join(sub_dir_path, json_file)
                    yield self._create_event(
                        log_level="INFO",
                        message=f"Processing JSON file: {json_file}",
                        app_name=app_name,
                        collection_name=collection_name,
                        json_file=json_file,
                        _raw=f"INFO: Processing JSON file: '{json_file}' for KV store '{collection_name}' in app '{app_name}'."
                    )

                    # Post the JSON file data (using yield from to get events from _post_json_data)
                    yield from self._post_json_data(
                        json_file_path, splunk_host, auth_token, app_name, collection_name, dry_run
                    )


# This is the entry point for the Splunk search command
dispatch(KVStoreMigrator, sys.argv, sys.stdin, sys.stdout, __name__)